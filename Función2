Set-StrictMode -Version Latest
function Procesos-Conexion{

<#
.SYNOPSIS
    Returns a list of services that are set to start automatically, are not
    currently running, excluding the services that are set to delayed start.

.DESCRIPTION
    Get-MrAutoStoppedService is a function that returns a list of services
    from the specified remote computer(s) that are set to start
    automatically, are not currently running, and it excludes the services
    that are set to start automatically with a delayed startup.

.PARAMETER ComputerName
    The remote computer(s) to check the status of the services on.

.PARAMETER Credential
    Specifies a user account that has permission to perform this action. The
    default is the current user.

.EXAMPLE
     Get-MrAutoStoppedService -ComputerName 'Server1', 'Server2'

.EXAMPLE
     'Server1', 'Server2' | Get-MrAutoStoppedService

.EXAMPLE
     Get-MrAutoStoppedService -ComputerName 'Server1' -Credential (Get-Credential)

.INPUTS
    String

.OUTPUTS
    PSCustomObject

.NOTES
    Author:  Equipo programación pa seguridad
    Grupo: 062
#>

    #obtiene procesos
    $procesosAct=Get-Process 

    #obtiene pids activos
    $pidsConectados = Get-NetTCPConnection -State Established | Select-Object -ExpandProperty OwningProcess
    #Relaciona los id de procesos con los pids, guarda coincidencias
    $procesosInternet = $procesosAct | Where-Object { $_.Id -in $pidsConectados }

    #Obtiene info sobre conexiones de procesos conectados a internet
    $net=Get-NetTCPConnection -State Established | Select-Object LocalPort, RemoteAddress, RemotePort, OwningProcess
    #Relaciona la información con sus respectivo proceso, crea un nuevo objeto combinando la información deseada.
    $procesosNetInfo = foreach ($conexion in $net){
    $proceso= $procesosInternet | Where-Object { $_.Id -eq $conexion.OwningProcess}
    if ($proceso) {
        [PSCustomObject]@{
            ProcessName = $proceso.ProcessName
            ID = $proceso.Id
            Path = $proceso.Path
            LocalPort = $conexion.LocalPort
            RemoteAddress = $conexion.RemoteAddress
            RemotePort = $conexion.RemotePort}}}
   
   #Imprime los procesos activos
   function ProcesosActivos {
        Write-Host -BackgroundColor Cyan -ForegroundColor Black "Lista de procesos activos"
        $procesosAct | ForEach-Object {$index=0} {$_; $index++} | Format-Table -Property @{ Label="#"; Expression={$index}}, Name, Id, Path -AutoSize
    }

    #Imprime los procesos conectados a internet
    function ProcesosInternet{
        Write-Host -BackgroundColor Green -ForegroundColor Black "Procesos conenctados a internet"
        $procesosInternet | Format-Table ProcessName, Id, Path -AutoSize
    }

    #Imprime los procesos conectados con más información sobre la conexión
    function InfoConexion{
        $procesosNetInfo | Format-Table -AutoSize
    }

    #Imprime si los procesos cuentan con firma digital 
    function FirmaDigital{
        Write-Host -BackgroundColor Magenta -ForegroundColor Black "Combrobación de firmas digitales de procesos activos conectados"
        $procesosInternet | ForEach-Object{
            try {
                if (Get-AuthenticodeSignature $_.Path){
                Write-Host "$($_.ProcessName) cuenta con firma digital ✔️"
            }else{
                Write-Host "$($_.ProcessName) NO cuenta con firma digital 🚨🚨🚨"} 
            }
            catch{
                Write-Host "$($_.ProcessName) NO cuenta con una ruta para comprbar"
            }        
        }

    }


    
    #tengo que llamar a la función, y ya esa función que pregunte o mande a llamar a las otras funciones. 
    ProcesosActivos 
    ProcesosInternet
    InfoConexion
    FirmaDigital

    #NOTA: mandar a pedir un parametro desde afuera para saber que función interna ejecutar. 

}
